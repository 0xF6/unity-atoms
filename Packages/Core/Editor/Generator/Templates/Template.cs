using System;
using System.Collections.Generic;
using System.Linq;
using System.Net;

namespace UnityAtoms.Editor
{
    public class Template
    {
        private struct Data
        {
            public string namespaces;
            public string withNamespace;
            public string typeName;
            public string attributes;
            public string nestedMenu;
        }

        public const string autoGeneratedWarning =
@"//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a function.
//
//     Changes to this file may cause incorrect behavior and will be lost
//     if the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------";

        private static Data GetData(Type type, out string className, string withNamespace = default)
        {
            Data data = default;

            HashSet<string> importedNamespaces = new HashSet<string>();
            AddImportedNamespace(nameof(UnityEngine));

            className = string.Empty;
            data.typeName = string.Empty;
            int lastTypeNameLength;
            GenerateClassName(type, ref className);

            data.nestedMenu = "/" + className.Insert(lastTypeNameLength, "/").TrimEnd('/');

            if (!string.IsNullOrEmpty(withNamespace))
            {
                data.nestedMenu += "/" + withNamespace.Replace('.', '/');

                var specialName = $"/{nameof(UnityAtoms)}";
                var specialNameIndex = data.nestedMenu.IndexOf(specialName);
                if (specialNameIndex != -1)
                {
                    data.nestedMenu = data.nestedMenu.Remove(specialNameIndex, specialName.Length);
                }

                data.withNamespace = $"namespace {withNamespace}";
            }
            else
            {
                data.withNamespace = string.Empty;
            }

            foreach(var attribute in type.CustomAttributes)
            {
                AddImportedNamespace(attribute.AttributeType.Namespace);

                data.attributes += $"{attribute.ToString().Replace($"{attribute.AttributeType.Namespace}.", string.Empty)}\n\t";
            }

            data.namespaces = string.Empty;
            foreach (var importedNamespace in importedNamespaces.OrderBy(importedNamespace => importedNamespace))
            {
                data.namespaces += $"using {importedNamespace};\n";
            }

            return data;

            void AddImportedNamespace(string importedNamespace)
            {
                if (!string.IsNullOrEmpty(importedNamespace)
                    && (string.IsNullOrEmpty(data.withNamespace) || !data.withNamespace.StartsWith(importedNamespace)))
                {
                    importedNamespaces.Add(importedNamespace);
                }
            }

            void GenerateClassName(Type type, ref string className, bool comma = false)
            {
                if (comma)
                {
                    data.typeName += ", ";
                }

                if (!type.IsKeyword())
                {
                    AddImportedNamespace(type.Namespace);
                }

                var nameOfType = type.CSharpName().TrimEnd('1').TrimEnd('`');
                className = nameOfType.Capitalize() + className;

                var declaringType = type.DeclaringType;
                while(declaringType != null)
                {
                    var nameOfDeclaringType = declaringType.CSharpName().TrimEnd('1').TrimEnd('`');

                    nameOfType = $"{nameOfDeclaringType}.{nameOfType}";
                    className = nameOfDeclaringType.Capitalize() + className;

                    declaringType = declaringType.DeclaringType;
                }

                data.typeName += nameOfType;
                lastTypeNameLength = nameOfType.Length;

                if (type.IsGenericType)
                {
                    data.typeName += "<";
                    for (int i = type.GenericTypeArguments.Length - 1; i >= 0; i--)
                    {
                        var genericTypeArgument = type.GenericTypeArguments[i];
                        GenerateClassName(genericTypeArgument, ref className, i != type.GenericTypeArguments.Length - 1);
                    }
                    data.typeName += ">";
                }
            }
        }

        public static string ResolveAtom(Type type, out string className, string withNamespace = default)
        {
            var data = GetData(type, out className, withNamespace);

            string openingBrackets;
            string closingBrackets;
            if(!string.IsNullOrEmpty(withNamespace))
            {
                openingBrackets = "{";
                closingBrackets = "}";
            }
            else
            {
                openingBrackets = string.Empty;
                closingBrackets = string.Empty;
            }

            return
$@"{autoGeneratedWarning}

{data.namespaces}
{data.withNamespace}
{openingBrackets}
    /// <summary>
    /// Inherits from {WebUtility.HtmlEncode(data.typeName)}.
    /// </summary>
    {data.attributes}[CreateAssetMenu(menuName = ""Atoms{data.nestedMenu}"", fileName = ""{className}"")]
    public sealed class {className} : {data.typeName} {{}}
{closingBrackets}
";
        }
    }
}

